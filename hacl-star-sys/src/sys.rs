/* automatically generated by rust-bindgen */

pub const Spec_Hash_Definitions_SHA2_224: u32 = 0;
pub const Spec_Hash_Definitions_SHA2_256: u32 = 1;
pub const Spec_Hash_Definitions_SHA2_384: u32 = 2;
pub const Spec_Hash_Definitions_SHA2_512: u32 = 3;
pub const Spec_Hash_Definitions_SHA1: u32 = 4;
pub const Spec_Hash_Definitions_MD5: u32 = 5;
pub const Spec_Agile_Cipher_AES128: u32 = 0;
pub const Spec_Agile_Cipher_AES256: u32 = 1;
pub const Spec_Agile_Cipher_CHACHA20: u32 = 2;
pub const Spec_Cipher_Expansion_Hacl_CHACHA20: u32 = 0;
pub const Spec_Cipher_Expansion_Vale_AES128: u32 = 1;
pub const Spec_Cipher_Expansion_Vale_AES256: u32 = 2;
pub const Spec_Agile_AEAD_AES128_GCM: u32 = 0;
pub const Spec_Agile_AEAD_AES256_GCM: u32 = 1;
pub const Spec_Agile_AEAD_CHACHA20_POLY1305: u32 = 2;
pub const Spec_Agile_AEAD_AES128_CCM: u32 = 3;
pub const Spec_Agile_AEAD_AES256_CCM: u32 = 4;
pub const Spec_Agile_AEAD_AES128_CCM8: u32 = 5;
pub const Spec_Agile_AEAD_AES256_CCM8: u32 = 6;
pub const EverCrypt_Hash_MD5_s: u32 = 0;
pub const EverCrypt_Hash_SHA1_s: u32 = 1;
pub const EverCrypt_Hash_SHA2_224_s: u32 = 2;
pub const EverCrypt_Hash_SHA2_256_s: u32 = 3;
pub const EverCrypt_Hash_SHA2_384_s: u32 = 4;
pub const EverCrypt_Hash_SHA2_512_s: u32 = 5;
pub const EverCrypt_Error_Success: u32 = 0;
pub const EverCrypt_Error_UnsupportedAlgorithm: u32 = 1;
pub const EverCrypt_Error_InvalidKey: u32 = 2;
pub const EverCrypt_Error_AuthenticationFailure: u32 = 3;
pub const EverCrypt_Error_InvalidIVLength: u32 = 4;
pub const EverCrypt_Error_DecodeError: u32 = 5;
pub const EverCrypt_OpenSSL_AES128_GCM: u32 = 0;
pub const EverCrypt_OpenSSL_AES256_GCM: u32 = 1;
pub const EverCrypt_OpenSSL_CHACHA20_POLY1305: u32 = 2;
pub const EverCrypt_OpenSSL_ECC_P256: u32 = 0;
pub const EverCrypt_OpenSSL_ECC_P384: u32 = 1;
pub const EverCrypt_OpenSSL_ECC_P521: u32 = 2;
pub const EverCrypt_OpenSSL_ECC_X25519: u32 = 3;
pub const EverCrypt_OpenSSL_ECC_X448: u32 = 4;
pub const EverCrypt_AES128_OPENSSL: u32 = 0;
pub const EverCrypt_AES128_BCRYPT: u32 = 1;
pub const EverCrypt_AES128_VALE: u32 = 2;
pub const EverCrypt_AES128_HACL: u32 = 3;
pub const EverCrypt_AES256_OPENSSL: u32 = 0;
pub const EverCrypt_AES256_BCRYPT: u32 = 1;
pub const EverCrypt_AES256_HACL: u32 = 2;
pub const EverCrypt_AES128_CBC: u32 = 0;
pub const EverCrypt_AES256_CBC: u32 = 1;
pub const EverCrypt_TDES_EDE_CBC: u32 = 2;
pub const EverCrypt_RC4_128: u32 = 0;
pub const EverCrypt_AES128_GCM: u32 = 0;
pub const EverCrypt_AES256_GCM: u32 = 1;
pub const EverCrypt_CHACHA20_POLY1305: u32 = 2;
pub const EverCrypt_AES128_CCM: u32 = 3;
pub const EverCrypt_AES256_CCM: u32 = 4;
pub const EverCrypt_AES128_CCM8: u32 = 5;
pub const EverCrypt_AES256_CCM8: u32 = 6;
pub const EverCrypt_AEAD_OPENSSL: u32 = 0;
pub const EverCrypt_AEAD_BCRYPT: u32 = 1;
pub const EverCrypt_AEAD_AES128_GCM_VALE: u32 = 2;
pub const EverCrypt_AEAD_AES256_GCM_VALE: u32 = 3;
pub const EverCrypt_AEAD_CHACHA20_POLY1305_HACL: u32 = 4;
pub const EverCrypt_DH_OPENSSL: u32 = 0;
pub const EverCrypt_DH_DUMMY: u32 = 1;
pub const EverCrypt_ECC_P256: u32 = 0;
pub const EverCrypt_ECC_P384: u32 = 1;
pub const EverCrypt_ECC_P521: u32 = 2;
pub const EverCrypt_ECC_X25519: u32 = 3;
pub const EverCrypt_ECC_X448: u32 = 4;
pub const EverCrypt_ECDH_OPENSSL: u32 = 0;
pub const EverCrypt_ECDH_DUMMY: u32 = 1;
pub const EverCrypt_DRBG_SHA1_s: u32 = 0;
pub const EverCrypt_DRBG_SHA2_256_s: u32 = 1;
pub const EverCrypt_DRBG_SHA2_384_s: u32 = 2;
pub const EverCrypt_DRBG_SHA2_512_s: u32 = 3;
pub type __uint8_t = crate::libc::c_uchar;
pub type __uint16_t = crate::libc::c_ushort;
pub type __uint32_t = crate::libc::c_uint;
pub type __uint64_t = crate::libc::c_ulong;
pub type FStar_Dyn_dyn = *mut crate::libc::c_void;
pub type C_String_t = *const crate::libc::c_char;
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_shaext() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_aesni() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_pclmulqdq() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx2() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_avx() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_bmi2() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_adx() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_sse() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_movbe() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_has_rdrand() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_wants_vale() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_wants_hacl() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_wants_openssl() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_wants_bcrypt() -> bool;
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_recall();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_init();
}
pub type EverCrypt_AutoConfig2_disabler = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx2();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_avx();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_bmi2();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_adx();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_shaext();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_aesni();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_pclmulqdq();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_sse();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_movbe();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_rdrand();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_vale();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_hacl();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_openssl();
}
extern "C" {
    pub fn EverCrypt_AutoConfig2_disable_bcrypt();
}
pub type Spec_Hash_Definitions_hash_alg = u8;
pub type Spec_Agile_Cipher_cipher_alg = u8;
pub type Spec_Cipher_Expansion_impl = u8;
extern "C" {
    pub fn Spec_Cipher_Expansion_cipher_alg_of_impl(
        i: Spec_Cipher_Expansion_impl,
    ) -> Spec_Agile_Cipher_cipher_alg;
}
pub type Spec_Agile_AEAD_alg = u8;
pub type EverCrypt_Helpers_uint8_t = u8;
pub type EverCrypt_Helpers_uint16_t = u16;
pub type EverCrypt_Helpers_uint32_t = u32;
pub type EverCrypt_Helpers_uint64_t = u64;
pub type EverCrypt_Helpers_uint8_p = *mut u8;
pub type EverCrypt_Helpers_uint16_p = *mut u16;
pub type EverCrypt_Helpers_uint32_p = *mut u32;
pub type EverCrypt_Helpers_uint64_p = *mut u64;
pub type EverCrypt_Hash_alg = Spec_Hash_Definitions_hash_alg;
extern "C" {
    pub fn EverCrypt_Hash_string_of_alg(uu___0_6: Spec_Hash_Definitions_hash_alg) -> C_String_t;
}
pub type EverCrypt_Hash_broken_alg = Spec_Hash_Definitions_hash_alg;
pub type EverCrypt_Hash_alg13 = Spec_Hash_Definitions_hash_alg;
pub type EverCrypt_Hash_e_alg = *mut crate::libc::c_void;
pub type EverCrypt_Hash_state_s_tags = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct EverCrypt_Hash_state_s_s {
    pub tag: EverCrypt_Hash_state_s_tags,
    pub val: EverCrypt_Hash_state_s_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EverCrypt_Hash_state_s_s__bindgen_ty_1 {
    pub case_MD5_s: *mut u32,
    pub case_SHA1_s: *mut u32,
    pub case_SHA2_224_s: *mut u32,
    pub case_SHA2_256_s: *mut u32,
    pub case_SHA2_384_s: *mut u64,
    pub case_SHA2_512_s: *mut u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_EverCrypt_Hash_state_s_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EverCrypt_Hash_state_s_s__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<EverCrypt_Hash_state_s_s__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s__bindgen_ty_1>())).case_MD5_s
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1),
            "::",
            stringify!(case_MD5_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s__bindgen_ty_1>())).case_SHA1_s
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1),
            "::",
            stringify!(case_SHA1_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s__bindgen_ty_1>())).case_SHA2_224_s
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1),
            "::",
            stringify!(case_SHA2_224_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s__bindgen_ty_1>())).case_SHA2_256_s
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1),
            "::",
            stringify!(case_SHA2_256_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s__bindgen_ty_1>())).case_SHA2_384_s
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1),
            "::",
            stringify!(case_SHA2_384_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s__bindgen_ty_1>())).case_SHA2_512_s
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s__bindgen_ty_1),
            "::",
            stringify!(case_SHA2_512_s)
        )
    );
}
#[test]
fn bindgen_test_layout_EverCrypt_Hash_state_s_s() {
    assert_eq!(
        ::core::mem::size_of::<EverCrypt_Hash_state_s_s>(),
        16usize,
        concat!("Size of: ", stringify!(EverCrypt_Hash_state_s_s))
    );
    assert_eq!(
        ::core::mem::align_of::<EverCrypt_Hash_state_s_s>(),
        8usize,
        concat!("Alignment of ", stringify!(EverCrypt_Hash_state_s_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<EverCrypt_Hash_state_s_s>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EverCrypt_Hash_state_s_s),
            "::",
            stringify!(val)
        )
    );
}
pub type EverCrypt_Hash_state_s = EverCrypt_Hash_state_s_s;
extern "C" {
    pub fn EverCrypt_Hash_uu___is_MD5_s(
        uu____151: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash___proj__MD5_s__item__p(
        uu____179: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> *mut u32;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA1_s(
        uu____202: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash___proj__SHA1_s__item__p(
        uu____230: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> *mut u32;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_224_s(
        uu____253: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash___proj__SHA2_224_s__item__p(
        uu____281: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> *mut u32;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_256_s(
        uu____304: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash___proj__SHA2_256_s__item__p(
        uu____332: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> *mut u32;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_384_s(
        uu____355: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash___proj__SHA2_384_s__item__p(
        uu____383: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> *mut u64;
}
extern "C" {
    pub fn EverCrypt_Hash_uu___is_SHA2_512_s(
        uu____406: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash___proj__SHA2_512_s__item__p(
        uu____434: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_state_s,
    ) -> *mut u64;
}
extern "C" {
    pub fn EverCrypt_Hash_alg_of_state(
        s: *mut EverCrypt_Hash_state_s,
    ) -> Spec_Hash_Definitions_hash_alg;
}
extern "C" {
    pub fn EverCrypt_Hash_create_in(
        a: Spec_Hash_Definitions_hash_alg,
    ) -> *mut EverCrypt_Hash_state_s;
}
extern "C" {
    pub fn EverCrypt_Hash_create(a: Spec_Hash_Definitions_hash_alg) -> *mut EverCrypt_Hash_state_s;
}
extern "C" {
    pub fn EverCrypt_Hash_init(s: *mut EverCrypt_Hash_state_s);
}
extern "C" {
    pub fn EverCrypt_Hash_update_multi_256(s: *mut u32, blocks: *mut u8, n1: u32);
}
extern "C" {
    pub fn EverCrypt_Hash_update(s: *mut EverCrypt_Hash_state_s, block1: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_update_multi(s: *mut EverCrypt_Hash_state_s, blocks: *mut u8, len: u32);
}
extern "C" {
    pub fn EverCrypt_Hash_update_last_256(
        s: *mut u32,
        prev_len: u64,
        input: *mut u8,
        input_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_update_last(
        s: *mut EverCrypt_Hash_state_s,
        last1: *mut u8,
        total_len: u64,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_finish(s: *mut EverCrypt_Hash_state_s, dst: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_free(s: *mut EverCrypt_Hash_state_s);
}
extern "C" {
    pub fn EverCrypt_Hash_copy(
        s_src: *mut EverCrypt_Hash_state_s,
        s_dst: *mut EverCrypt_Hash_state_s,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_hash_256(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_hash_224(input: *mut u8, input_len: u32, dst: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Hash_hash(
        a: Spec_Hash_Definitions_hash_alg,
        dst: *mut u8,
        input: *mut u8,
        len: u32,
    );
}
pub type EverCrypt_Hash_Incremental_any_hash_t = *mut u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_Hash_Incremental_state_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_Hash_Incremental_state_s = EverCrypt_Hash_Incremental_state_s_s;
extern "C" {
    pub fn EverCrypt_Hash_Incremental_uu___is_State(
        a: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_Incremental_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental___proj__State__item__hash_state(
        a: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_Incremental_state_s,
    ) -> *mut EverCrypt_Hash_state_s;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental___proj__State__item__buf(
        a: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_Incremental_state_s,
    ) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental___proj__State__item__total_len(
        a: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_Hash_Incremental_state_s,
    ) -> u64;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_alg_of_state(
        s: *mut EverCrypt_Hash_Incremental_state_s,
    ) -> Spec_Hash_Definitions_hash_alg;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_create_in(
        a: Spec_Hash_Definitions_hash_alg,
    ) -> *mut EverCrypt_Hash_Incremental_state_s;
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_init(s: *mut EverCrypt_Hash_Incremental_state_s);
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_update(
        p1: *mut EverCrypt_Hash_Incremental_state_s,
        data: *mut u8,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_finish(
        s: *mut EverCrypt_Hash_Incremental_state_s,
        dst: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Hash_Incremental_free(s: *mut EverCrypt_Hash_Incremental_state_s);
}
pub type EverCrypt_Error_error_code = u8;
extern "C" {
    pub fn EverCrypt_Error_uu___is_Success(projectee: EverCrypt_Error_error_code) -> bool;
}
extern "C" {
    pub fn EverCrypt_Error_uu___is_UnsupportedAlgorithm(
        projectee: EverCrypt_Error_error_code,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Error_uu___is_InvalidKey(projectee: EverCrypt_Error_error_code) -> bool;
}
extern "C" {
    pub fn EverCrypt_Error_uu___is_AuthenticationFailure(
        projectee: EverCrypt_Error_error_code,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Error_uu___is_InvalidIVLength(projectee: EverCrypt_Error_error_code) -> bool;
}
extern "C" {
    pub fn EverCrypt_Error_uu___is_DecodeError(projectee: EverCrypt_Error_error_code) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_CTR_state_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_CTR_state_s = EverCrypt_CTR_state_s_s;
extern "C" {
    pub fn EverCrypt_CTR_uu___is_State(
        a: Spec_Agile_Cipher_cipher_alg,
        projectee: EverCrypt_CTR_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_CTR___proj__State__item__i(
        a: Spec_Agile_Cipher_cipher_alg,
        projectee: EverCrypt_CTR_state_s,
    ) -> Spec_Cipher_Expansion_impl;
}
extern "C" {
    pub fn EverCrypt_CTR___proj__State__item__iv(
        a: Spec_Agile_Cipher_cipher_alg,
        projectee: EverCrypt_CTR_state_s,
    ) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt_CTR___proj__State__item__iv_len(
        a: Spec_Agile_Cipher_cipher_alg,
        projectee: EverCrypt_CTR_state_s,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_CTR___proj__State__item__xkey(
        a: Spec_Agile_Cipher_cipher_alg,
        projectee: EverCrypt_CTR_state_s,
    ) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt_CTR___proj__State__item__ctr(
        a: Spec_Agile_Cipher_cipher_alg,
        projectee: EverCrypt_CTR_state_s,
    ) -> u32;
}
pub type EverCrypt_CTR_uint8 = u8;
extern "C" {
    pub fn EverCrypt_CTR_xor8(a: u8, b: u8) -> u8;
}
pub type EverCrypt_CTR_e_alg = *mut crate::libc::c_void;
extern "C" {
    pub fn EverCrypt_CTR_alg_of_state(
        s: *mut EverCrypt_CTR_state_s,
    ) -> Spec_Agile_Cipher_cipher_alg;
}
extern "C" {
    pub fn EverCrypt_CTR_create_in(
        a: Spec_Agile_Cipher_cipher_alg,
        dst: *mut *mut EverCrypt_CTR_state_s,
        k1: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        c: u32,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_CTR_init(
        p: *mut EverCrypt_CTR_state_s,
        k1: *mut u8,
        iv: *mut u8,
        iv_len: u32,
        c: u32,
    );
}
extern "C" {
    pub fn EverCrypt_CTR_update_block(p: *mut EverCrypt_CTR_state_s, dst: *mut u8, src: *mut u8);
}
extern "C" {
    pub fn EverCrypt_CTR_free(p: *mut EverCrypt_CTR_state_s);
}
extern "C" {
    pub fn EverCrypt_OpenSSL_random_init() -> u32;
}
extern "C" {
    pub fn EverCrypt_OpenSSL_random_sample(len: u32, out: *mut u8);
}
extern "C" {
    pub fn EverCrypt_OpenSSL_aes128_gcm_encrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plain: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_OpenSSL_aes128_gcm_decrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plain: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_OpenSSL_aes256_gcm_encrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plain: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_OpenSSL_aes256_gcm_decrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plain: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> u32;
}
pub type EverCrypt_OpenSSL_alg = u8;
extern "C" {
    pub fn EverCrypt_OpenSSL_aead_create(alg: EverCrypt_OpenSSL_alg, key: *mut u8)
        -> FStar_Dyn_dyn;
}
extern "C" {
    pub fn EverCrypt_OpenSSL_aead_encrypt(
        key: FStar_Dyn_dyn,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plain: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_OpenSSL_aead_decrypt(
        key: FStar_Dyn_dyn,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plain: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_OpenSSL_aead_free(key: FStar_Dyn_dyn);
}
extern "C" {
    pub fn EverCrypt_OpenSSL_dh_load_group(
        dh_p: *mut u8,
        dh_p_len: u32,
        dh_g: *mut u8,
        dh_g_len: u32,
        dh_q: *mut u8,
        dh_q_len: u32,
    ) -> FStar_Dyn_dyn;
}
extern "C" {
    pub fn EverCrypt_OpenSSL_dh_free_group(st: FStar_Dyn_dyn);
}
extern "C" {
    pub fn EverCrypt_OpenSSL_dh_keygen(st: FStar_Dyn_dyn, out: *mut u8) -> u32;
}
extern "C" {
    pub fn EverCrypt_OpenSSL_dh_compute(
        st: FStar_Dyn_dyn,
        public: *mut u8,
        public_len: u32,
        out: *mut u8,
    ) -> u32;
}
pub type EverCrypt_OpenSSL_ec_curve = u8;
extern "C" {
    pub fn EverCrypt_OpenSSL_ecdh_load_curve(g: EverCrypt_OpenSSL_ec_curve) -> FStar_Dyn_dyn;
}
extern "C" {
    pub fn EverCrypt_OpenSSL_ecdh_free_curve(st: FStar_Dyn_dyn);
}
extern "C" {
    pub fn EverCrypt_OpenSSL_ecdh_keygen(st: FStar_Dyn_dyn, outx: *mut u8, outy: *mut u8);
}
extern "C" {
    pub fn EverCrypt_OpenSSL_ecdh_compute(
        st: FStar_Dyn_dyn,
        inx: *mut u8,
        iny: *mut u8,
        out: *mut u8,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_Ed25519_sign(signature: *mut u8, secret1: *mut u8, len: u32, msg: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_verify(
        output: *mut u8,
        len: u32,
        msg: *mut u8,
        signature: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_Ed25519_secret_to_public(output: *mut u8, secret1: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_expand_keys(ks: *mut u8, secret1: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Ed25519_sign_expanded(signature: *mut u8, ks: *mut u8, len: u32, msg: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Chacha20Poly1305_aead_encrypt(
        k: *mut u8,
        n1: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        tag: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_Chacha20Poly1305_aead_decrypt(
        k: *mut u8,
        n1: *mut u8,
        aadlen: u32,
        aad: *mut u8,
        mlen: u32,
        m: *mut u8,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_AEAD_state_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_AEAD_state_s = EverCrypt_AEAD_state_s_s;
extern "C" {
    pub fn EverCrypt_AEAD_uu___is_Ek(
        a: Spec_Agile_AEAD_alg,
        projectee: EverCrypt_AEAD_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_AEAD___proj__Ek__item__impl(
        a: Spec_Agile_AEAD_alg,
        projectee: EverCrypt_AEAD_state_s,
    ) -> Spec_Cipher_Expansion_impl;
}
extern "C" {
    pub fn EverCrypt_AEAD___proj__Ek__item__ek(
        a: Spec_Agile_AEAD_alg,
        projectee: EverCrypt_AEAD_state_s,
    ) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt_AEAD_alg_of_state(s: *mut EverCrypt_AEAD_state_s) -> Spec_Agile_AEAD_alg;
}
extern "C" {
    pub fn EverCrypt_AEAD_create_in(
        a: Spec_Agile_AEAD_alg,
        dst: *mut *mut EverCrypt_AEAD_state_s,
        k1: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_encrypt(
        s: *mut EverCrypt_AEAD_state_s,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        plain: *mut u8,
        plain_len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_decrypt(
        s: *mut EverCrypt_AEAD_state_s,
        iv: *mut u8,
        iv_len: u32,
        ad: *mut u8,
        ad_len: u32,
        cipher: *mut u8,
        cipher_len: u32,
        tag: *mut u8,
        dst: *mut u8,
    ) -> EverCrypt_Error_error_code;
}
extern "C" {
    pub fn EverCrypt_AEAD_free(s: *mut EverCrypt_AEAD_state_s);
}
extern "C" {
    pub fn EverCrypt_random_init() -> u32;
}
extern "C" {
    pub fn EverCrypt_random_sample(len: u32, out1: *mut u8);
}
extern "C" {
    pub fn EverCrypt_random_cleanup();
}
pub type EverCrypt_aes128_key_s_tags = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_aes128_key_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_aes128_key_s = EverCrypt_aes128_key_s_s;
extern "C" {
    pub fn EverCrypt_uu___is_AES128_OPENSSL(projectee: EverCrypt_aes128_key_s) -> bool;
}
extern "C" {
    pub fn EverCrypt___proj__AES128_OPENSSL__item__st(
        projectee: EverCrypt_aes128_key_s,
    ) -> FStar_Dyn_dyn;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES128_BCRYPT(projectee: EverCrypt_aes128_key_s) -> bool;
}
extern "C" {
    pub fn EverCrypt___proj__AES128_BCRYPT__item__st(
        projectee: EverCrypt_aes128_key_s,
    ) -> FStar_Dyn_dyn;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES128_VALE(projectee: EverCrypt_aes128_key_s) -> bool;
}
extern "C" {
    pub fn EverCrypt___proj__AES128_VALE__item__w(projectee: EverCrypt_aes128_key_s) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt___proj__AES128_VALE__item__sbox(projectee: EverCrypt_aes128_key_s) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES128_HACL(projectee: EverCrypt_aes128_key_s) -> bool;
}
extern "C" {
    pub fn EverCrypt___proj__AES128_HACL__item__w(projectee: EverCrypt_aes128_key_s) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt___proj__AES128_HACL__item__sbox(projectee: EverCrypt_aes128_key_s) -> *mut u8;
}
pub type EverCrypt_aes128_key = *mut EverCrypt_aes128_key_s;
extern "C" {
    pub fn EverCrypt_aes128_create(k1: *mut u8) -> *mut EverCrypt_aes128_key_s;
}
extern "C" {
    pub fn EverCrypt_aes128_compute(
        k1: *mut EverCrypt_aes128_key_s,
        plain: *mut u8,
        cipher: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_aes128_free(pk: *mut EverCrypt_aes128_key_s);
}
pub type EverCrypt_aes256_key_s_tags = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_aes256_key_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_aes256_key_s = EverCrypt_aes256_key_s_s;
extern "C" {
    pub fn EverCrypt_uu___is_AES256_OPENSSL(projectee: EverCrypt_aes256_key_s) -> bool;
}
extern "C" {
    pub fn EverCrypt___proj__AES256_OPENSSL__item__st(
        projectee: EverCrypt_aes256_key_s,
    ) -> FStar_Dyn_dyn;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES256_BCRYPT(projectee: EverCrypt_aes256_key_s) -> bool;
}
extern "C" {
    pub fn EverCrypt___proj__AES256_BCRYPT__item__st(
        projectee: EverCrypt_aes256_key_s,
    ) -> FStar_Dyn_dyn;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES256_HACL(projectee: EverCrypt_aes256_key_s) -> bool;
}
extern "C" {
    pub fn EverCrypt___proj__AES256_HACL__item__w(projectee: EverCrypt_aes256_key_s) -> *mut u8;
}
extern "C" {
    pub fn EverCrypt___proj__AES256_HACL__item__sbox(projectee: EverCrypt_aes256_key_s) -> *mut u8;
}
pub type EverCrypt_aes256_key = *mut EverCrypt_aes256_key_s;
extern "C" {
    pub fn EverCrypt_aes256_create(k1: *mut u8) -> *mut EverCrypt_aes256_key_s;
}
extern "C" {
    pub fn EverCrypt_aes256_compute(
        k1: *mut EverCrypt_aes256_key_s,
        plain: *mut u8,
        cipher: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_aes256_free(pk: *mut EverCrypt_aes256_key_s);
}
extern "C" {
    pub fn EverCrypt_aes128_gcm_encrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plaintext: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_aes128_gcm_decrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plaintext: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_aes256_gcm_encrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plaintext: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_aes256_gcm_decrypt(
        key: *mut u8,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plaintext: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> u32;
}
pub type EverCrypt_block_cipher_alg = u8;
extern "C" {
    pub fn EverCrypt_uu___is_AES128_CBC(projectee: EverCrypt_block_cipher_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES256_CBC(projectee: EverCrypt_block_cipher_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_TDES_EDE_CBC(projectee: EverCrypt_block_cipher_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_block_cipher_keyLen(uu___0_9512: EverCrypt_block_cipher_alg) -> u32;
}
extern "C" {
    pub fn EverCrypt_block_cipher_blockLen(uu___1_9522: EverCrypt_block_cipher_alg) -> u32;
}
pub type EverCrypt_stream_cipher_alg = u8;
extern "C" {
    pub fn EverCrypt_uu___is_RC4_128(projectee: EverCrypt_stream_cipher_alg) -> bool;
}
pub type EverCrypt_aead_alg = u8;
extern "C" {
    pub fn EverCrypt_uu___is_AES128_GCM(projectee: EverCrypt_aead_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES256_GCM(projectee: EverCrypt_aead_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_CHACHA20_POLY1305(projectee: EverCrypt_aead_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES128_CCM(projectee: EverCrypt_aead_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES256_CCM(projectee: EverCrypt_aead_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES128_CCM8(projectee: EverCrypt_aead_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_AES256_CCM8(projectee: EverCrypt_aead_alg) -> bool;
}
extern "C" {
    pub fn EverCrypt_aead_keyLen(uu___2_9629: EverCrypt_aead_alg) -> u32;
}
extern "C" {
    pub fn EverCrypt_aead_tagLen(uu___3_9643: EverCrypt_aead_alg) -> u32;
}
extern "C" {
    pub fn EverCrypt_aead_ivLen(a: EverCrypt_aead_alg) -> u32;
}
pub type EverCrypt__aead_state_tags = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt__aead_state_s {
    _unused: [u8; 0],
}
pub type EverCrypt__aead_state = EverCrypt__aead_state_s;
pub type EverCrypt_aead_state_s = EverCrypt__aead_state;
pub type EverCrypt_aead_state = *mut EverCrypt__aead_state;
extern "C" {
    pub fn EverCrypt_aead_create(
        alg: EverCrypt_aead_alg,
        k1: *mut u8,
    ) -> *mut EverCrypt__aead_state;
}
extern "C" {
    pub fn EverCrypt_aead_encrypt(
        pkey: *mut EverCrypt__aead_state,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plaintext: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    );
}
extern "C" {
    pub fn EverCrypt_aead_decrypt(
        pkey: *mut EverCrypt__aead_state,
        iv: *mut u8,
        ad: *mut u8,
        adlen: u32,
        plaintext: *mut u8,
        len: u32,
        cipher: *mut u8,
        tag: *mut u8,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_aead_free(pk: *mut EverCrypt__aead_state);
}
pub type EverCrypt__dh_state_tags = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt__dh_state_s {
    _unused: [u8; 0],
}
pub type EverCrypt__dh_state = EverCrypt__dh_state_s;
pub type EverCrypt_dh_state_s = EverCrypt__dh_state;
pub type EverCrypt_dh_state = *mut EverCrypt__dh_state;
extern "C" {
    pub fn EverCrypt_dh_load_group(
        dh_p: *mut u8,
        dh_p_len: u32,
        dh_g: *mut u8,
        dh_g_len: u32,
        dh_q: *mut u8,
        dh_q_len: u32,
    ) -> *mut EverCrypt__dh_state;
}
extern "C" {
    pub fn EverCrypt_dh_free_group(st: *mut EverCrypt__dh_state);
}
extern "C" {
    pub fn EverCrypt_dh_keygen(st: *mut EverCrypt__dh_state, public: *mut u8) -> u32;
}
extern "C" {
    pub fn EverCrypt_dh_compute(
        st: *mut EverCrypt__dh_state,
        public: *mut u8,
        public_len: u32,
        out1: *mut u8,
    ) -> u32;
}
pub type EverCrypt_ec_curve = u8;
extern "C" {
    pub fn EverCrypt_uu___is_ECC_P256(projectee: EverCrypt_ec_curve) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_ECC_P384(projectee: EverCrypt_ec_curve) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_ECC_P521(projectee: EverCrypt_ec_curve) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_ECC_X25519(projectee: EverCrypt_ec_curve) -> bool;
}
extern "C" {
    pub fn EverCrypt_uu___is_ECC_X448(projectee: EverCrypt_ec_curve) -> bool;
}
pub type EverCrypt__ecdh_state_tags = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt__ecdh_state_s {
    _unused: [u8; 0],
}
pub type EverCrypt__ecdh_state = EverCrypt__ecdh_state_s;
pub type EverCrypt_ecdh_state_s = EverCrypt__ecdh_state;
pub type EverCrypt_ecdh_state = *mut EverCrypt__ecdh_state;
extern "C" {
    pub fn EverCrypt_ecdh_load_curve(g1: EverCrypt_ec_curve) -> *mut EverCrypt__ecdh_state;
}
extern "C" {
    pub fn EverCrypt_ecdh_free_curve(st: *mut EverCrypt__ecdh_state);
}
extern "C" {
    pub fn EverCrypt_ecdh_keygen(st: *mut EverCrypt__ecdh_state, outx: *mut u8, outy: *mut u8);
}
extern "C" {
    pub fn EverCrypt_ecdh_compute(
        st: *mut EverCrypt__ecdh_state,
        inx: *mut u8,
        iny: *mut u8,
        out1: *mut u8,
    ) -> u32;
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha1(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha2_256(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha2_384(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_compute_sha2_512(
        dst: *mut u8,
        key: *mut u8,
        key_len: u32,
        data: *mut u8,
        data_len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HMAC_is_supported_alg(uu___0_5843: Spec_Hash_Definitions_hash_alg) -> bool;
}
pub type EverCrypt_HMAC_supported_alg = Spec_Hash_Definitions_hash_alg;
extern "C" {
    pub fn EverCrypt_HMAC_compute(
        a: Spec_Hash_Definitions_hash_alg,
        mac: *mut u8,
        key: *mut u8,
        keylen: u32,
        data: *mut u8,
        datalen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha1(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha1(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha2_256(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha2_256(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha2_384(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha2_384(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand_sha2_512(
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract_sha2_512(
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_expand(
        a: Spec_Hash_Definitions_hash_alg,
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_extract(
        a: Spec_Hash_Definitions_hash_alg,
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_hkdf_expand(
        a: Spec_Hash_Definitions_hash_alg,
        okm: *mut u8,
        prk: *mut u8,
        prklen: u32,
        info: *mut u8,
        infolen: u32,
        len: u32,
    );
}
extern "C" {
    pub fn EverCrypt_HKDF_hkdf_extract(
        a: Spec_Hash_Definitions_hash_alg,
        prk: *mut u8,
        salt: *mut u8,
        saltlen: u32,
        ikm: *mut u8,
        ikmlen: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hacl_HMAC_DRBG_state_s {
    pub k: *mut u8,
    pub v: *mut u8,
    pub reseed_counter: *mut u32,
}
#[test]
fn bindgen_test_layout_Hacl_HMAC_DRBG_state_s() {
    assert_eq!(
        ::core::mem::size_of::<Hacl_HMAC_DRBG_state_s>(),
        24usize,
        concat!("Size of: ", stringify!(Hacl_HMAC_DRBG_state_s))
    );
    assert_eq!(
        ::core::mem::align_of::<Hacl_HMAC_DRBG_state_s>(),
        8usize,
        concat!("Alignment of ", stringify!(Hacl_HMAC_DRBG_state_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Hacl_HMAC_DRBG_state_s>())).k as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Hacl_HMAC_DRBG_state_s),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Hacl_HMAC_DRBG_state_s>())).v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Hacl_HMAC_DRBG_state_s),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<Hacl_HMAC_DRBG_state_s>())).reseed_counter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Hacl_HMAC_DRBG_state_s),
            "::",
            stringify!(reseed_counter)
        )
    );
}
pub type Hacl_HMAC_DRBG_state = Hacl_HMAC_DRBG_state_s;
pub type EverCrypt_DRBG_supported_alg = Spec_Hash_Definitions_hash_alg;
extern "C" {
    pub static mut EverCrypt_DRBG_reseed_interval: u32;
}
extern "C" {
    pub static mut EverCrypt_DRBG_max_output_length: u32;
}
extern "C" {
    pub static mut EverCrypt_DRBG_max_length: u32;
}
extern "C" {
    pub static mut EverCrypt_DRBG_max_personalization_string_length: u32;
}
extern "C" {
    pub static mut EverCrypt_DRBG_max_additional_input_length: u32;
}
extern "C" {
    pub fn EverCrypt_DRBG_min_length(a: Spec_Hash_Definitions_hash_alg) -> u32;
}
pub type EverCrypt_DRBG_state_s_tags = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EverCrypt_DRBG_state_s_s {
    _unused: [u8; 0],
}
pub type EverCrypt_DRBG_state_s = EverCrypt_DRBG_state_s_s;
extern "C" {
    pub fn EverCrypt_DRBG_uu___is_SHA1_s(
        uu____164: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG___proj__SHA1_s__item___0(
        uu____207: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> Hacl_HMAC_DRBG_state;
}
extern "C" {
    pub fn EverCrypt_DRBG_uu___is_SHA2_256_s(
        uu____239: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG___proj__SHA2_256_s__item___0(
        uu____282: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> Hacl_HMAC_DRBG_state;
}
extern "C" {
    pub fn EverCrypt_DRBG_uu___is_SHA2_384_s(
        uu____314: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG___proj__SHA2_384_s__item___0(
        uu____357: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> Hacl_HMAC_DRBG_state;
}
extern "C" {
    pub fn EverCrypt_DRBG_uu___is_SHA2_512_s(
        uu____389: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG___proj__SHA2_512_s__item___0(
        uu____432: Spec_Hash_Definitions_hash_alg,
        projectee: EverCrypt_DRBG_state_s,
    ) -> Hacl_HMAC_DRBG_state;
}
extern "C" {
    pub fn EverCrypt_DRBG_create(a: Spec_Hash_Definitions_hash_alg) -> *mut EverCrypt_DRBG_state_s;
}
extern "C" {
    pub fn EverCrypt_DRBG_instantiate_sha1(
        st: *mut EverCrypt_DRBG_state_s,
        personalization_string: *mut u8,
        personalization_string_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_instantiate_sha2_256(
        st: *mut EverCrypt_DRBG_state_s,
        personalization_string: *mut u8,
        personalization_string_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_instantiate_sha2_384(
        st: *mut EverCrypt_DRBG_state_s,
        personalization_string: *mut u8,
        personalization_string_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_instantiate_sha2_512(
        st: *mut EverCrypt_DRBG_state_s,
        personalization_string: *mut u8,
        personalization_string_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_reseed_sha1(
        st: *mut EverCrypt_DRBG_state_s,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_reseed_sha2_256(
        st: *mut EverCrypt_DRBG_state_s,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_reseed_sha2_384(
        st: *mut EverCrypt_DRBG_state_s,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_reseed_sha2_512(
        st: *mut EverCrypt_DRBG_state_s,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_generate_sha1(
        output: *mut u8,
        st: *mut EverCrypt_DRBG_state_s,
        n1: u32,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_generate_sha2_256(
        output: *mut u8,
        st: *mut EverCrypt_DRBG_state_s,
        n1: u32,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_generate_sha2_384(
        output: *mut u8,
        st: *mut EverCrypt_DRBG_state_s,
        n1: u32,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_generate_sha2_512(
        output: *mut u8,
        st: *mut EverCrypt_DRBG_state_s,
        n1: u32,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_uninstantiate_sha1(st: *mut EverCrypt_DRBG_state_s);
}
extern "C" {
    pub fn EverCrypt_DRBG_uninstantiate_sha2_256(st: *mut EverCrypt_DRBG_state_s);
}
extern "C" {
    pub fn EverCrypt_DRBG_uninstantiate_sha2_384(st: *mut EverCrypt_DRBG_state_s);
}
extern "C" {
    pub fn EverCrypt_DRBG_uninstantiate_sha2_512(st: *mut EverCrypt_DRBG_state_s);
}
extern "C" {
    pub fn EverCrypt_DRBG_instantiate(
        st: *mut EverCrypt_DRBG_state_s,
        personalization_string: *mut u8,
        personalization_string_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_reseed(
        st: *mut EverCrypt_DRBG_state_s,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_generate(
        output: *mut u8,
        st: *mut EverCrypt_DRBG_state_s,
        n1: u32,
        additional_input: *mut u8,
        additional_input_len: u32,
    ) -> bool;
}
extern "C" {
    pub fn EverCrypt_DRBG_uninstantiate(st: *mut EverCrypt_DRBG_state_s);
}
extern "C" {
    pub fn EverCrypt_Poly1305_poly1305(dst: *mut u8, src: *mut u8, len: u32, key: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Curve25519_secret_to_public(pub_: *mut u8, priv_: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Curve25519_scalarmult(shared: *mut u8, my_priv: *mut u8, their_pub: *mut u8);
}
extern "C" {
    pub fn EverCrypt_Curve25519_ecdh(shared: *mut u8, my_priv: *mut u8, their_pub: *mut u8)
        -> bool;
}
extern "C" {
    pub fn EverCrypt_Cipher_chacha20(
        len: u32,
        dst: *mut u8,
        src: *mut u8,
        key: *mut u8,
        iv: *mut u8,
        ctr: u32,
    );
}
extern "C" {
    pub static mut EverCrypt_StaticConfig_hacl: bool;
}
extern "C" {
    pub static mut EverCrypt_StaticConfig_vale: bool;
}
extern "C" {
    pub static mut EverCrypt_StaticConfig_openssl: bool;
}
extern "C" {
    pub static mut EverCrypt_StaticConfig_bcrypt: bool;
}
